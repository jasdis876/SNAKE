<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mobile Snake</title>
  <style>
    *{
      margin:0;padding:0;box-sizing:border-box;
      -webkit-tap-highlight-color:transparent;
      -webkit-touch-callout:none;
      -webkit-user-select:none;user-select:none;
    }
    html,body{
      height:100%;
      overflow:hidden;
      background:#000;
      font-family:monospace,system-ui,sans-serif;
      color:#FFD400;
      touch-action:none;
    }
    #container{
      display:flex;
      flex-direction:column;
      height:100%;
      width:100%;
      padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    #scoreContainer{
      text-align:center;
      padding:10px;
      font-size:1.6rem;
      font-weight:900;
      background:#111;
      letter-spacing:1px;
    }
    #canvasWrapper{
      flex:1;
      display:flex;
      justify-content:center;
      align-items:center;
      position:relative;
      overflow:hidden;
      padding:8px;
    }
    canvas{
      display:block;
      background:#000;
      max-width:100%;
      max-height:100%;
      image-rendering:pixelated;
      touch-action:none;
      border:1px solid rgba(255,212,0,.25);
    }
    #landscapeWarning{
      display:none;
      position:absolute;
      inset:0;
      background:rgba(0,0,0,.92);
      color:#FFD400;
      justify-content:center;
      align-items:center;
      text-align:center;
      padding:20px;
      font-size:1.35rem;
      z-index:20;
      pointer-events:auto;
    }
    #overlay{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,.86);
      display:none;
      justify-content:center;
      align-items:center;
      flex-direction:column;
      color:#FFFF00;
      font-size:2.2rem;
      font-weight:900;
      text-align:center;
      z-index:15;
      padding:20px;
      pointer-events:auto;
    }
    #overlaySub{
      font-size:1.15rem;
      margin-top:14px;
      color:#FFD400;
      font-weight:700;
    }
    #controls{
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:12px 14px;
      background:#111;
      gap:10px;
    }
    .dpadRow{
      display:flex;
      justify-content:center;
      gap:10px;
    }
    .dpadBtn{
      width:70px;height:70px;
      background:#222;
      color:#FFD400;
      border:2px solid #FFD400;
      border-radius:12px;
      font-size:1.9rem;
      display:flex;
      justify-content:center;
      align-items:center;
      touch-action:manipulation;
    }
    .dpadBtn:active{ background:#333; }
    @media (max-height:720px){
      #scoreContainer{font-size:1.45rem;}
      .dpadBtn{width:64px;height:64px;font-size:1.7rem;}
      #controls{padding:10px 12px;gap:8px;}
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="scoreContainer">SCORE: <span id="score">0</span></div>

    <div id="canvasWrapper">
      <canvas id="gameCanvas"></canvas>

      <div id="landscapeWarning">üì± Please rotate to portrait mode to play!</div>

      <div id="overlay">
        <div id="overlayText">GAME OVER</div>
        <div id="overlaySub">Tap to Restart</div>
      </div>
    </div>

    <div id="controls">
      <div class="dpadRow">
        <div class="dpadBtn" id="upBtn" aria-label="Up">‚Üë</div>
      </div>
      <div class="dpadRow">
        <div class="dpadBtn" id="leftBtn" aria-label="Left">‚Üê</div>
        <div class="dpadBtn" id="downBtn" aria-label="Down">‚Üì</div>
        <div class="dpadBtn" id="rightBtn" aria-label="Right">‚Üí</div>
      </div>
    </div>
  </div>

  <script>
    (function(){
      "use strict";

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d", { alpha:false });
      const scoreEl = document.getElementById("score");
      const overlay = document.getElementById("overlay");
      const overlayText = document.getElementById("overlayText");
      const overlaySub = document.getElementById("overlaySub");
      const landscapeWarning = document.getElementById("landscapeWarning");

      const upBtn = document.getElementById("upBtn");
      const downBtn = document.getElementById("downBtn");
      const leftBtn = document.getElementById("leftBtn");
      const rightBtn = document.getElementById("rightBtn");

      const CELL = 20; // pixel size per cell (logical)
      let gridW = 0, gridH = 0, dpr = 1;

      let snake = [];
      let food = {x:0,y:0};
      let dir = {x:1,y:0};
      let queued = {x:1,y:0};
      let turnLocked = false;

      let score = 0;
      let gameOver = false;

      const BASE_SPEED = 10;      // moves/sec
      const SPEED_INC = 0.5;      // every 5 points
      const MAX_SPEED  = 20;
      let speed = BASE_SPEED;

      let lastT = 0;
      let acc = 0;

      function isLandscape(){
        return window.innerWidth > window.innerHeight;
      }

      function showOverlay(on, title, sub){
        overlay.style.display = on ? "flex" : "none";
        if (title) overlayText.textContent = title;
        if (sub) overlaySub.textContent = sub;
      }

      function resize(){
        const wrap = document.getElementById("canvasWrapper");

        const land = isLandscape();
        landscapeWarning.style.display = land ? "flex" : "none";
        canvas.style.display = land ? "none" : "block";

        const usable = Math.min(wrap.clientWidth, wrap.clientHeight);
        const cssSize = Math.max(240, Math.floor(usable));
        const cells = Math.max(15, Math.floor(cssSize / CELL));

        gridW = cells;
        gridH = cells;

        dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        canvas.style.width = (gridW * CELL) + "px";
        canvas.style.height = (gridH * CELL) + "px";
        canvas.width = Math.floor(gridW * CELL * dpr);
        canvas.height = Math.floor(gridH * CELL * dpr);

        ctx.setTransform(1,0,0,1,0,0);
        ctx.scale(dpr,dpr);

        // Always restart safely after resize/orientation change
        reset();
      }

      function initSnake(){
        const sx = Math.floor(gridW/2);
        const sy = Math.floor(gridH/2);
        snake = [
          {x:sx, y:sy},
          {x:sx-1, y:sy},
          {x:sx-2, y:sy}
        ];
      }

      function placeFood(){
        const occ = new Set(snake.map(s => s.x + "," + s.y));
        const empties = [];
        for (let x=0; x<gridW; x++){
          for (let y=0; y<gridH; y++){
            const k = x + "," + y;
            if (!occ.has(k)) empties.push({x,y});
          }
        }
        if (empties.length === 0){
          gameOver = true;
          showOverlay(true, "YOU WIN!", "Tap to Restart");
          return;
        }
        food = empties[(Math.random() * empties.length) | 0];
      }

      function reset(){
        if (!gridW || !gridH) return;

        score = 0;
        scoreEl.textContent = "0";

        dir = {x:1,y:0};
        queued = {x:1,y:0};
        turnLocked = false;

        speed = BASE_SPEED;
        gameOver = false;
        showOverlay(false);

        initSnake();
        placeFood();

        acc = 0;
        lastT = performance.now();

        draw();
      }

      function setDir(nd){
        if (gameOver) return;
        if (turnLocked) return;

        // prevent reverse vs current dir
        if (nd.x === -dir.x && nd.y === -dir.y) return;
        // ignore same direction
        if (nd.x === dir.x && nd.y === dir.y) return;

        queued = {x:nd.x, y:nd.y};
        turnLocked = true;
      }

      function step(){
        if (gameOver) return;
        if (!snake.length) return;

        dir = {x:queued.x, y:queued.y};

        const head = snake[0];
        let nx = head.x + dir.x;
        let ny = head.y + dir.y;

        // wrap
        if (nx < 0) nx = gridW - 1;
        if (nx >= gridW) nx = 0;
        if (ny < 0) ny = gridH - 1;
        if (ny >= gridH) ny = 0;

        const willEat = (nx === food.x && ny === food.y);

        // collision check: ignore tail if not eating
        const checkLen = willEat ? snake.length : snake.length - 1;
        for (let i=0; i<checkLen; i++){
          if (snake[i].x === nx && snake[i].y === ny){
            gameOver = true;
            showOverlay(true, "GAME OVER", "Tap to Restart");
            return;
          }
        }

        snake.unshift({x:nx, y:ny});

        if (willEat){
          score++;
          scoreEl.textContent = String(score);
          if (score % 5 === 0 && speed < MAX_SPEED){
            speed = Math.min(MAX_SPEED, speed + SPEED_INC);
          }
          placeFood();
        } else {
          snake.pop();
        }

        turnLocked = false;
      }

      function draw(){
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,gridW*CELL, gridH*CELL);

        // food
        ctx.save();
        ctx.fillStyle = "#FFD400";
        ctx.shadowColor = "#FFD400";
        ctx.shadowBlur = 10;
        const fx = food.x * CELL + CELL/2;
        const fy = food.y * CELL + CELL/2;
        ctx.beginPath();
        ctx.arc(fx, fy, CELL/2 - 2, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        // snake
        ctx.save();
        ctx.fillStyle = "#FFD400";
        ctx.shadowColor = "#FFD400";
        ctx.shadowBlur = 8;
        for (let i=0; i<snake.length; i++){
          const s = snake[i];
          ctx.fillRect(s.x*CELL+1, s.y*CELL+1, CELL-2, CELL-2);
        }
        ctx.restore();
      }

      function loop(t){
        requestAnimationFrame(loop);

        if (isLandscape()){
          draw();
          return;
        }

        if (!lastT) lastT = t;
        let dt = (t - lastT)/1000;
        lastT = t;

        if (dt > 0.25) dt = 0.25;

        acc += dt;
        if (acc > 0.2) acc = 0.2;

        const stepTime = 1 / speed;
        while (acc >= stepTime){
          step();
          acc -= stepTime;
        }

        draw();
      }

      // Reliable mobile press binding
      function bindPress(el, fn){
        el.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          e.stopPropagation();
          fn();
        }, { passive:false });
      }

      bindPress(upBtn,    () => setDir({x:0,y:-1}));
      bindPress(downBtn,  () => setDir({x:0,y: 1}));
      bindPress(leftBtn,  () => setDir({x:-1,y:0}));
      bindPress(rightBtn, () => setDir({x: 1,y:0}));

      // Overlay tap restart
      overlay.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        reset();
      }, { passive:false });

      // Swipe support on canvas
      let start = null;
      canvas.addEventListener("pointerdown", (e) => {
        if (gameOver){
          e.preventDefault();
          reset();
          return;
        }
        start = {x:e.clientX, y:e.clientY};
      }, { passive:false });

      canvas.addEventListener("pointerup", (e) => {
        if (!start) return;
        const end = {x:e.clientX, y:e.clientY};
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        start = null;

        const min = 30;
        if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > min){
          setDir({x: dx > 0 ? 1 : -1, y:0});
        } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > min){
          setDir({x:0, y: dy > 0 ? 1 : -1});
        }
      }, { passive:false });

      canvas.addEventListener("pointermove", (e) => e.preventDefault(), { passive:false });
      document.addEventListener("touchmove", (e) => e.preventDefault(), { passive:false });

      // Resize/orientation
      let rTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(rTimer);
        rTimer = setTimeout(resize, 80);
      });
      window.addEventListener("orientationchange", () => setTimeout(resize, 120));

      // Boot
      resize();
      reset();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
